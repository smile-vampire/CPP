//题目描述
//二货小易有一个W* H的网格盒子，网格的行编号为0~H - 1，网格的列编号为0~W - 1。
//每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。
//对于两个格子坐标(x1, y1), (x2, y2)的欧几里得距离为:
//((x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2)) 的算术平方根
//小易想知道最多可以放多少块蛋糕在网格盒子里。

//解题思路：
//本题本质就是在二维数组中每个坐标去放蛋糕，
//一个坐标位置放了蛋糕，跟他欧几里得距离为2的位置不能放蛋糕，对于两个格子坐标
//(x1, y1), (x2, y2)的欧几里得距离为: ((x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2)) 的算术平方根 。
//也就是说：如果(x1, y1)放了蛋糕，则满足((x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2)) == 4的(x2, y2)不能放蛋
//糕。
//((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) == 4。
//可以进行加法表达式分解：
//1 + 3 = 4
//3 + 1 = 4
//2 + 2 = 4
//0 + 4 = 4
//4 + 0 = 4
//仔细分析前三个表达式是不可能的，因为(x1 - x2) * (x1 - x2)表达式结果不能等于2或3。
//也就是说((x1 - x2) * (x1 - x2) 和(y1 - y2) * (y1 - y2))两个表达式一个等于0，一个等于4.
//可以看出：假设放蛋糕的位置是(x1, y1)，则不能放蛋糕的位置(x2, y2)，满足x1x2, y1 - y2或者x1 - x2, y1y2
//使用vector<vector<int>>定义一个二维数组，resize开空间并初始化，每个位置初始化为1，
//表示当蛋糕，a[i][j]位置放蛋糕，则可以标记处a[i][j + 2]和a[i + 1][j]位置
//不能放蛋糕，遍历一遍二维数组，标记处不能放蛋糕的位置，统计也就统计出了当蛋糕的位置数

#include<iostream>
#include<vector>
using namespace std;
int main()
{
	int w, h, res = 0;
	cin >> w >> h;
	vector<vector<int>> a;
	a.resize(w);
	for (auto& e : a)
		e.resize(h, 1);
	for (int i = 0; i < w; i++)
	{
		for (int j = 0; j < h; j++)
		{
			if (a[i][j] == 1)
			{
				res++;
				// 标记不能放蛋糕的位置
				if ((i + 2) < w)
					a[i + 2][j] = 0;
				if ((j + 2) < h)
					a[i][j + 2] = 0;
			}
		}
	}
	cout << res;
	return 0;
}